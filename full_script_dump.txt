================================================================================
FILE: git_push_project.py
================================================================================
import subprocess
import os
from pathlib import Path
import sys

def run_git_command(args, error_msg):
    print(f"Running: {' '.join(args)}")
    try:
        result = subprocess.run(args, capture_output=True, text=True, check=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"Error: {error_msg}")
        print(e.stderr)
        return None

def main():
    project_dir = Path("/Users/stevencohen/Projects/universal_recycling/orders_project")
    branch = "main"

    # Change to project directory
    try:
        os.chdir(project_dir)
    except FileNotFoundError:
        print(f"Error: Directory {project_dir} not found")
        sys.exit(1)

    print("üì¶ Starting Git push process...")

    # Stage everything (including untracked files)
    run_git_command(["git", "add", "--all"], "Failed to stage changes")

    # Check if anything is staged
    diff = run_git_command(["git", "diff", "--cached", "--name-only"], "Failed to check staged files")
    if not diff.strip():
        print("‚úÖ Nothing to commit or push.")
        return

    # Commit the changes
    commit_msg = "Auto-commit for push (script)"
    run_git_command(["git", "commit", "-m", commit_msg], "Failed to commit changes")

    # Pull with rebase to avoid conflicts
    if run_git_command(["git", "pull", "--rebase", "origin", branch], "Pull failed") is None:
        print("‚ùå Pull failed. Resolve manually.")
        return

    # Push to GitHub
    if run_git_command(["git", "push", "origin", branch], "Push failed") is None:
        print("‚ùå Push failed. Resolve manually.")
        return

    print("üöÄ Push completed successfully!")

if __name__ == "__main__":
    main()


================================================================================
FILE: WORKING_STYLE.md
================================================================================
# Working Style Notes

## About Me
- 63 years old
- Experienced application designer
- Focus on design and architecture, not coding implementation
- Value direct, proactive communication
- Don't want to be asked permission for every little thing
- Need clear, direct communication about what needs to be done

## Reality of AI Capabilities
- AI can SUGGEST changes but cannot MAKE changes directly
- When AI says "I'll create/edit/delete" - these are suggestions that need to be applied
- The "Apply" button in Cursor means "make these changes real"
- Sometimes manual file operations (create/delete) are faster than using Cursor

## How I Want the AI to Work
- Be 100% honest about what you can and cannot do
- Don't pretend you've made changes when you've only suggested them
- Tell me clearly when I need to do something manually
- Don't ask permission for suggestions - just make them
- Keep documentation updated
- Leverage your technical knowledge while respecting my design experience

## How to Handle Common Situations
- File Creation: Tell me if you're suggesting it or if I should create it manually
- File Deletion: Just tell me to delete it manually if that's faster
- Code Changes: Show the changes needed, tell me when to click Apply
- Running Code: Explain the difference between applying changes and running code

## Communication Style
- Be direct and clear
- Don't apologize repeatedly
- Don't ask permission for every little thing
- Do tell me when something needs my action
- Do explain technical concepts without assuming coding knowledge
- Do admit when something isn't working and suggest alternatives

## Session Start
Paste this file's contents at the start of each new Cursor session to set the working context.

## Important Notes
1. When you see "Apply" in Cursor:
   - This means the changes aren't real yet
   - Click Apply to actually make the changes
   - Sometimes multiple Apply buttons mean multiple changes need to be made

2. When something isn't working:
   - Don't waste time with repeated failed attempts
   - Ask if manual intervention would be faster
   - Be clear about what's not working and why

3. Remember:
   - AI suggests, YOU apply
   - Manual file operations are often faster
   - It's okay to ask for clarification
   - Direct action is better than endless discussion


================================================================================
FILE: integration_tests.py
================================================================================
"""
Requisition System Integration Test Suite
----------------------------------------
A comprehensive test suite that validates the full requisition pipeline
from login through submission to database storage and frontend display.
"""

import os
import sys
import json
import time
import requests
import unittest
import traceback
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from datetime import datetime, timedelta
import uuid
import re

# Install required packages with:
# pip install selenium requests webdriver-manager

class TestResult:
    """Stores the result of a single test case with before/after state"""
    def __init__(self, name):
        self.name = name
        self.start_time = datetime.now()
        self.end_time = None
        self.passed = False
        self.before_state = {}
        self.after_state = {}
        self.assertions = []
        self.error = None
        self.stacktrace = None
    
    def add_assertion(self, assertion_name, passed, expected=None, actual=None):
        """Add a single assertion result"""
        self.assertions.append({
            "name": assertion_name,
            "passed": passed,
            "expected": expected,
            "actual": actual
        })
    
    def set_before_state(self, state):
        """Set the before state snapshot"""
        self.before_state = state
    
    def set_after_state(self, state):
        """Set the after state snapshot"""
        self.after_state = state
    
    def set_error(self, error, stacktrace):
        """Record an error with stacktrace"""
        self.error = str(error)
        self.stacktrace = stacktrace
    
    def finalize(self, passed):
        """Mark the test as complete with final result"""
        self.passed = passed
        self.end_time = datetime.now()
    
    def to_dict(self):
        """Convert to dictionary for serialization"""
        return {
            "name": self.name,
            "duration": (self.end_time - self.start_time).total_seconds() if self.end_time else None,
            "passed": self.passed,
            "before_state": self.before_state,
            "after_state": self.after_state,
            "assertions": self.assertions,
            "error": self.error,
            "stacktrace": self.stacktrace
        }
    
    def __str__(self):
        """Format the test result for display"""
        result = f"Test: {self.name}\n"
        result += f"Status: {'PASSED' if self.passed else 'FAILED'}\n"
        result += f"Duration: {(self.end_time - self.start_time).total_seconds():.2f}s\n\n"
        
        # Print before state
        result += "Before State:\n"
        result += json.dumps(self.before_state, indent=2) + "\n\n"
        
        # Print after state
        result += "After State:\n"
        result += json.dumps(self.after_state, indent=2) + "\n\n"
        
        # Print assertions
        result += "Assertions:\n"
        for assertion in self.assertions:
            status = "‚úì" if assertion["passed"] else "‚úó"
            result += f"{status} {assertion['name']}\n"
            if not assertion["passed"]:
                result += f"  Expected: {assertion['expected']}\n"
                result += f"  Actual:   {assertion['actual']}\n"
        
        # Print error
        if self.error:
            result += "\nError:\n"
            result += self.error + "\n\n"
            result += "Stacktrace:\n"
            result += self.stacktrace + "\n"
        
        return result

class ValidationSuite:
    """Collects and summarizes multiple test results"""
    def __init__(self):
        self.results = []
    
    def add_result(self, result):
        """Add a test result to the suite"""
        self.results.append(result)
    
    def print_summary(self):
        """Print a summary of all test results"""
        total = len(self.results)
        passed = sum(1 for r in self.results if r.passed)
        failed = total - passed
        
        print("\n===== VALIDATION SUMMARY =====")
        print(f"Total Tests: {total}")
        print(f"Passed: {passed}")
        print(f"Failed: {failed}")
        print(f"Success Rate: {(passed/total)*100:.2f}%")
        print("=============================\n")
        
        for result in self.results:
            print(result)
            print("-----------------------------\n")
    
    def has_failures(self):
        """Check if any tests failed"""
        return any(not r.passed for r in self.results)

class DatabaseHelper:
    """Helper for database operations via API"""
    def __init__(self, base_url):
        self.base_url = base_url
    
    def get_requisition_count(self):
        """Get the total number of requisitions"""
        response = requests.get(f"{self.base_url}/api/requisitions")
        if response.status_code == 200:
            return len(response.json())
        return 0
    
    def get_transaction_count(self):
        """Get the total number of transactions"""
        response = requests.get(f"{self.base_url}/api/transactions")
        if response.status_code == 200:
            return len(response.json())
        return 0
    
    def get_requisition_by_order_number(self, order_number):
        """Get a requisition by its order number"""
        response = requests.get(f"{self.base_url}/api/requisitions")
        if response.status_code == 200:
            requisitions = response.json()
            return [r for r in requisitions if r.get("order_number") == order_number]
        return []
    
    def get_requisition_items(self, requisition_id):
        """Get all items for a requisition"""
        response = requests.get(f"{self.base_url}/api/requisition_items/{requisition_id}")
        if response.status_code == 200:
            return response.json()
        return []
    
    def get_transaction_by_order_number(self, order_number):
        """Get a transaction by its order number"""
        response = requests.get(f"{self.base_url}/api/transactions")
        if response.status_code == 200:
            transactions = response.json()
            return [t for t in transactions if t.get("order_number") == order_number]
        return []
    
    def get_next_order_number(self):
        """Get the next order number from settings"""
        response = requests.get(f"{self.base_url}/api/settings/order_number_start")
        if response.status_code == 200:
            data = response.json()
            return data.get("order_number_start", 1000)
        return 1000

class RequisitionSystemTests:
    """Main test suite for the requisition system"""
    def __init__(self):
        self.base_url = "http://localhost:8000"
        self.validation = ValidationSuite()
        
        # Setup WebDriver for browser automation
        from webdriver_manager.chrome import ChromeDriverManager
        from selenium.webdriver.chrome.service import Service
        
        options = webdriver.ChromeOptions()
        options.add_argument("--headless")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        service = Service(ChromeDriverManager().install())
        self.driver = webdriver.Chrome(service=service, options=options)
        self.driver.implicitly_wait(10)
        
        # Setup database helper
        self.db = DatabaseHelper(self.base_url)
    
    def teardown(self):
        """Clean up resources"""
        if self.driver:
            self.driver.quit()
    
    def login(self, username="Steven"):
        """Log in to the application"""
        self.driver.get(self.base_url)
        
        try:
            # Check if already logged in
            if "currentUser" in self.driver.page_source:
                current_user = self.driver.find_element(By.ID, "currentUser").text
                if username in current_user:
                    return True
            
            # Enter username
            username_input = self.driver.find_element(By.ID, "username")
            username_input.clear()
            username_input.send_keys(username)
            
            # Submit form
            login_form = self.driver.find_element(By.ID, "loginForm")
            login_form.submit()
            
            # Wait for login to complete
            WebDriverWait(self.driver, 10).until(
                EC.visibility_of_element_located((By.ID, "mainApp"))
            )
            
            return True
        except Exception as e:
            print(f"Login failed: {e}")
            return False
    
    def fill_requisition_form(self, data):
        """Fill out the requisition form with test data"""
        # Navigate to form tab
        self.driver.get(self.base_url)
        
        # Wait for page to fully load
        time.sleep(5)
        print("Page loaded, checking for new requisition tab...")
        
        # Set a longer wait time
        wait = WebDriverWait(self.driver, 30)
        
        # Ensure we're on the new requisition tab
        try:
            # Try explicit wait first
            print("Waiting for new requisition tab button...")
            new_req_tab = wait.until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button.tab-button[onclick=\"showTab('new-requisition')\"]"))
            )
            print("Found tab button, clicking...")
            new_req_tab.click()
            print("Tab button clicked")
        except Exception as e:
            print(f"Error clicking tab button: {e}")
            # If direct click fails, try JavaScript click as fallback
            try:
                print("Attempting fallback method to find tab...")
                new_req_tab = self.driver.find_element(By.CSS_SELECTOR, "button.tab-button[onclick=\"showTab('new-requisition')\"]")
                print("Found tab via fallback, executing JavaScript click...")
                self.driver.execute_script("arguments[0].click();", new_req_tab)
                print("JavaScript click executed")
            except Exception as e2:
                print(f"Fallback method failed: {e2}")
                # Direct JavaScript call to the function as last resort
                print("Last resort: directly calling showTab function...")
                self.driver.execute_script("showTab('new-requisition');")
                print("showTab function called directly")
        
        # Wait for the form to be visible
        print("Waiting for requisition form to become visible...")
        wait.until(
            EC.visibility_of_element_located((By.ID, "requisitionForm"))
        )
        print("Form is now visible")
        
        # Fill form fields
        if "requestDate" in data:
            print("Setting request date...")
            date_input = wait.until(
                EC.element_to_be_clickable((By.ID, "requestDate"))
            )
            date_input.clear()
            date_input.send_keys(data["requestDate"])
            print("Request date set")
        
        if "requester" in data:
            print("Setting requester...")
            self.driver.find_element(By.ID, "requester").send_keys(data["requester"])
            print("Requester set")
        
        if "supplier" in data:
            print("Setting supplier...")
            self.driver.find_element(By.ID, "supplier").send_keys(data["supplier"])
            print("Supplier set")
        
        if "note" in data:
            print("Setting note...")
            self.driver.find_element(By.ID, "note").send_keys(data["note"])
            print("Note set")
        
        # Fill stock items
        print(f"About to fill {len(data.get('items', []))} stock items...")
        for i, item in enumerate(data.get("items", [])):
            print(f"Filling stock item {i+1}...")
            # If not first item, add new row
            if i > 0:
                print("Adding new row...")
                add_button = self.driver.find_elements(By.CSS_SELECTOR, ".action-square.green-square")[0]
                add_button.click()
                print("New row added")
            
            # Get all stock item rows
            rows = self.driver.find_elements(By.CSS_SELECTOR, ".stock-item-row")
            row = rows[i]
            
            # Select stock code
            print("Selecting stock code...")
            stock_select = row.find_element(By.CSS_SELECTOR, "select[name='stockCode[]']")
            wait.until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "select[name='stockCode[]'] option:nth-child(2)"))
            )
            options = stock_select.find_elements(By.TAG_NAME, "option")
            for option in options:
                if item.get("stockCode", "") in option.text:
                    option.click()
                    print(f"Selected stock code: {option.text}")
                    break
            else:
                # If not found, pick first non-empty
                for option in options:
                    if option.get_attribute("value"):
                        option.click()
                        print(f"Selected first available stock code: {option.text}")
                        break
            
            # Select project code
            print("Selecting project code...")
            wait.until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "select[name='projectCode[]']"))
            )
            project_select = row.find_element(By.CSS_SELECTOR, "select[name='projectCode[]']")
            options = project_select.find_elements(By.TAG_NAME, "option")
            for option in options:
                if option.get_attribute("value"):
                    option.click()
                    print(f"Selected project code: {option.text}")
                    break
            
            # Select sub category (wait for it to populate)
            print("Waiting for subcategories to populate...")
            try:
                wait.until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, "select[name='subCategory[]'] option:nth-child(2)"))
                )
                subcat_select = row.find_element(By.CSS_SELECTOR, "select[name='subCategory[]']")
                options = subcat_select.find_elements(By.TAG_NAME, "option")
                if len(options) > 1:
                    options[1].click()
                    print(f"Selected subcategory: {options[1].text}")
            except Exception as e:
                print(f"Error selecting subcategory: {e}, continuing anyway...")
            
            # Fill units and price
            print("Setting units...")
            units_input = row.find_element(By.CSS_SELECTOR, "input[name='units[]']")
            units_input.clear()
            units_input.send_keys(str(item.get("units", 1)))
            print(f"Units set to {item.get('units', 1)}")
            
            print("Setting price...")
            price_input = row.find_element(By.CSS_SELECTOR, "input[name='price[]']")
            price_input.clear()
            price_input.send_keys(str(item.get("price", 100)))
            print(f"Price set to {item.get('price', 100)}")
            
        print("Form filling complete")
    
    def submit_form(self, expect_alert=True):
        """Submit the requisition form"""
        submit_button = self.driver.find_element(By.CSS_SELECTOR, "#requisitionForm button[type='submit']")
        submit_button.click()
        
        if expect_alert:
            try:
                # Wait for alert and accept it
                WebDriverWait(self.driver, 10).until(EC.alert_is_present())
                alert = self.driver.switch_to.alert
                alert_text = alert.text
                alert.accept()
                return alert_text
            except TimeoutException:
                return None
        return None
    
    def check_session_active(self):
        """Check if user session is still active"""
        try:
            # Try to access currentUser element - should be visible if logged in
            current_user = self.driver.find_element(By.ID, "currentUser").text
            return len(current_user) > 0
        except:
            # If element not found, session likely ended
            return False
    
    def check_login_screen_visible(self):
        """Check if login screen is visible (user logged out)"""
        try:
            login_screen = self.driver.find_element(By.ID, "loginScreen")
            return login_screen.is_displayed()
        except:
            return False
    
    def check_transaction_in_audit_trail(self, order_number):
        """Check if a transaction appears in the audit trail tab"""
        # Navigate to audit trail tab
        self.driver.get(self.base_url)
        
        # Wait for page to fully load
        time.sleep(2)
        
        try:
            # Try explicit wait first
            audit_tab = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button.tab-button[onclick=\"showTab('audit-trail')\"]"))
            )
            audit_tab.click()
        except:
            # If direct click fails, try JavaScript click as fallback
            try:
                audit_tab = self.driver.find_element(By.CSS_SELECTOR, "button.tab-button[onclick=\"showTab('audit-trail')\"]")
                self.driver.execute_script("arguments[0].click();", audit_tab)
            except:
                # Direct JavaScript call to the function as last resort
                self.driver.execute_script("showTab('audit-trail');")
        
        # Wait for data to load
        time.sleep(2)
        
        # Check if transaction is in table
        try:
            transactions_table = self.driver.find_element(By.ID, "transactionsTableBody")
            rows = transactions_table.find_elements(By.TAG_NAME, "tr")
            for row in rows:
                cells = row.find_elements(By.TAG_NAME, "td")
                if len(cells) > 1 and order_number in cells[1].text:
                    return True
            return False
        except:
            return False
    
    def test_standard_requisition_submission(self):
        """
        Test a standard requisition submission flow from end to end
        
        Validates:
        - Login works
        - Form submission succeeds
        - Requisition is saved to database
        - Items are saved to database
        - Transaction is created
        - Order number increments
        - Session remains active
        - Audit trail shows the transaction
        """
        test_result = TestResult("Standard Requisition Submission")
        
        try:
            # Login
            logged_in = self.login()
            test_result.add_assertion("Login successful", logged_in)
            
            if not logged_in:
                raise Exception("Failed to login, cannot continue test")
            
            # Get initial state
            next_order_number = self.db.get_next_order_number()
            formatted_order_number = f"ORD-{next_order_number}"
            req_count_before = self.db.get_requisition_count()
            txn_count_before = self.db.get_transaction_count()
            
            before_state = {
                "next_order_number": next_order_number,
                "requisition_count": req_count_before,
                "transaction_count": txn_count_before,
                "logged_in": True
            }
            test_result.set_before_state(before_state)
            
            # Fill form with test data
            test_data = {
                "requestDate": "12/04/2024",
                "requester": "Integration Test",
                "supplier": "Validation Supplier",
                "note": "End-to-end integration test",
                "items": [
                    {"stockCode": "AB", "units": 5, "price": 100},
                    {"stockCode": "CD", "units": 2, "price": 200}
                ]
            }
            self.fill_requisition_form(test_data)
            
            # Submit form
            alert_text = self.submit_form()
            form_submitted = alert_text and "success" in alert_text.lower()
            test_result.add_assertion("Form submitted successfully", form_submitted, 
                                     "Alert with success message", alert_text)
            
            # Wait for processing
            time.sleep(3)
            
            # Check if still logged in
            still_logged_in = self.check_session_active()
            logged_out = self.check_login_screen_visible()
            test_result.add_assertion("Session remained active", still_logged_in,
                                     "User still logged in", f"Logged in: {still_logged_in}, Login screen visible: {logged_out}")
            
            # Get updated state from database
            req_count_after = self.db.get_requisition_count()
            txn_count_after = self.db.get_transaction_count()
            current_order_number = self.db.get_next_order_number()
            
            # Check requisition in database
            requisitions = self.db.get_requisition_by_order_number(formatted_order_number)
            requisition_created = len(requisitions) > 0
            test_result.add_assertion("Requisition created in database", requisition_created,
                                     "One requisition record", len(requisitions))
            
            if requisition_created:
                requisition = requisitions[0]
                requisition_id = requisition["id"]
                
                # Check requisition fields
                test_result.add_assertion("Requisition has correct order number", 
                                         requisition["order_number"] == formatted_order_number,
                                         formatted_order_number, requisition["order_number"])
                
                test_result.add_assertion("Requisition has correct requester", 
                                         requisition["requester"] == test_data["requester"],
                                         test_data["requester"], requisition["requester"])
                
                test_result.add_assertion("Requisition has correct supplier", 
                                         requisition["supplier"] == test_data["supplier"],
                                         test_data["supplier"], requisition["supplier"])
                
                test_result.add_assertion("Requisition has correct note", 
                                         requisition["supplier_note"] == test_data["note"],
                                         test_data["note"], requisition["supplier_note"])
                
                # Check requisition items
                req_items = self.db.get_requisition_items(requisition_id)
                items_created = len(req_items) == len(test_data["items"])
                test_result.add_assertion("All requisition items created", items_created,
                                         len(test_data["items"]), len(req_items))
                
                # Calculate expected total value
                expected_total = sum(item["units"] * item["price"] for item in test_data["items"])
                test_result.add_assertion("Requisition has correct total value", 
                                         float(requisition["total_order_value"]) == expected_total,
                                         expected_total, float(requisition["total_order_value"]))
                
                # Check transaction in database
                transactions = self.db.get_transaction_by_order_number(formatted_order_number)
                transaction_created = len(transactions) > 0
                test_result.add_assertion("Transaction created in database", transaction_created,
                                         "One transaction record", len(transactions))
                
                if transaction_created:
                    transaction = transactions[0]
                    
                    # Check transaction fields
                    test_result.add_assertion("Transaction has correct order number", 
                                             transaction["order_number"] == formatted_order_number,
                                             formatted_order_number, transaction["order_number"])
                    
                    test_result.add_assertion("Transaction has correct type", 
                                             transaction["transaction_type"] == "Order Placed",
                                             "Order Placed", transaction["transaction_type"])
                    
                    test_result.add_assertion("Transaction has correct amount", 
                                             float(transaction["amount"]) == expected_total,
                                             expected_total, float(transaction["amount"]))
                    
                    test_result.add_assertion("Transaction has correct user", 
                                             transaction["user"] == test_data["requester"],
                                             test_data["requester"], transaction["user"])
                    
                    test_result.add_assertion("Transaction has correct status", 
                                             transaction["status"] in ["Pending", "pending"],
                                             "Pending", transaction["status"])
            
            # Check if order number incremented
            order_number_incremented = current_order_number == next_order_number + 1
            test_result.add_assertion("Order number incremented", order_number_incremented,
                                     next_order_number + 1, current_order_number)
            
            # Check if transaction appears in audit trail
            in_audit_trail = self.check_transaction_in_audit_trail(formatted_order_number)
            test_result.add_assertion("Transaction visible in audit trail", in_audit_trail,
                                     "Transaction in audit table", in_audit_trail)
            
            # Record final state
            after_state = {
                "next_order_number": current_order_number,
                "requisition_count": req_count_after,
                "transaction_count": txn_count_after,
                "requisition_count_delta": req_count_after - req_count_before,
                "transaction_count_delta": txn_count_after - txn_count_before,
                "still_logged_in": still_logged_in,
                "requisition": requisitions[0] if requisitions else None,
                "transaction": transactions[0] if transactions else None,
                "items_count": len(req_items) if 'req_items' in locals() else 0
            }
            test_result.set_after_state(after_state)
            
            # Determine overall test result
            test_passed = all(assertion["passed"] for assertion in test_result.assertions)
            test_result.finalize(test_passed)
            
        except Exception as e:
            # Capture full stacktrace for debugging
            error_trace = traceback.format_exc()
            test_result.set_error(e, error_trace)
            test_result.finalize(False)
        
        finally:
            # Add result to validation suite
            self.validation.add_result(test_result)
            
        return test_result
    
    def test_session_persistence(self):
        """
        Test that user session persists after form submission
        
        Validates:
        - User remains logged in after submission
        - No redirect to login screen
        - User can navigate to other tabs after submission
        """
        test_result = TestResult("Session Persistence")
        
        try:
            # Login
            logged_in = self.login()
            test_result.add_assertion("Login successful", logged_in)
            
            if not logged_in:
                raise Exception("Failed to login, cannot continue test")
            
            # Get user info before submission
            current_user_before = self.driver.find_element(By.ID, "currentUser").text
            
            before_state = {
                "logged_in": logged_in,
                "username": current_user_before
            }
            test_result.set_before_state(before_state)
            
            # Fill form
            test_data = {
                "requestDate": "12/04/2024",
                "requester": "Session Test",
                "supplier": "Persistence Co",
                "note": "Testing session persistence",
                "items": [
                    {"stockCode": "AB", "units": 1, "price": 25}
                ]
            }
            self.fill_requisition_form(test_data)
            
            # Submit form
            alert_text = self.submit_form()
            form_submitted = alert_text and "success" in alert_text.lower()
            test_result.add_assertion("Form submitted successfully", form_submitted)
            
            # Wait for processing
            time.sleep(3)
            
            # Check if still logged in
            is_logged_in = self.check_session_active()
            login_screen_visible = self.check_login_screen_visible()
            
            test_result.add_assertion("User still logged in after submission", is_logged_in,
                                     "User logged in", is_logged_in)
            
            test_result.add_assertion("Login screen not shown after submission", not login_screen_visible,
                                     "Login screen hidden", login_screen_visible)
            
            # Try navigating to another tab
            try:
                pending_tab = self.driver.find_element(By.CSS_SELECTOR, "button.tab-button[onclick=\"showTab('pending')\"]")
                pending_tab.click()
                
                # Wait for tab content to load
                WebDriverWait(self.driver, 10).until(
                    EC.visibility_of_element_located((By.ID, "pending"))
                )
                
                pending_tab_visible = True
            except:
                pending_tab_visible = False
            
            test_result.add_assertion("Can navigate to other tabs after submission", pending_tab_visible)
            
            # If still logged in, get current user info
            current_user_after = None
            if is_logged_in:
                try:
                    current_user_after = self.driver.find_element(By.ID, "currentUser").text
                except:
                    current_user_after = None
            
            test_result.add_assertion("Username preserved after submission", 
                                     current_user_after == current_user_before,
                                     current_user_before, current_user_after)
            
            after_state = {
                "logged_in": is_logged_in,
                "username": current_user_after,
                "login_screen_visible": login_screen_visible,
                "navigation_functional": pending_tab_visible
            }
            test_result.set_after_state(after_state)
            
            # Determine overall test result
            test_passed = all(assertion["passed"] for assertion in test_result.assertions)
            test_result.finalize(test_passed)
            
        except Exception as e:
            # Capture full stacktrace for debugging
            error_trace = traceback.format_exc()
            test_result.set_error(e, error_trace)
            test_result.finalize(False)
        
        finally:
            # Add result to validation suite
            self.validation.add_result(test_result)
            
        return test_result
    
    def run_all_tests(self):
        try:
            # Run all tests in sequence
            print("Starting Standard Requisition Submission test...")
            self.test_standard_requisition_submission()
            
            print("Starting Session Persistence test...")
            self.test_session_persistence()
            
            # Print summary
            self.validation.print_summary()
            
            return not self.validation.has_failures()
        finally:
            self.teardown()

if __name__ == "__main__":
    print("Starting Requisition System Integration Tests...")
    tests = RequisitionSystemTests()
    success = tests.run_all_tests()
    sys.exit(0 if success else 1)


================================================================================
FILE: git_pull_project.py
================================================================================
import subprocess
import os
from pathlib import Path
import sys

def run_git_command(args, error_msg):
    print(f"Running: {' '.join(args)}")
    try:
        result = subprocess.run(args, capture_output=True, text=True, check=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"Error: {error_msg}")
        print(e.stderr)
        return None

def main():
    project_dir = Path("/Users/stevencohen/Projects/universal_recycling/orders_project")

    # Navigate to the project directory
    try:
        os.chdir(project_dir)
    except FileNotFoundError:
        print(f"‚ùå Directory {project_dir} not found.")
        sys.exit(1)

    print("üì• Starting Git pull for Universal Recycling Purchase Orders...")

    # Check for any local changes (modified, staged, or untracked)
    status = run_git_command(["git", "status", "--porcelain"], "Failed to check git status")
    stashed = False

    if status.strip():
        print("üì¶ Local changes detected. Stashing (incl. untracked)...")
        run_git_command(["git", "stash", "push", "-u", "-m", "Auto-stash for pull"], "Failed to stash changes")
        stashed = True

    # Pull from origin with rebase
    print("üîÑ Pulling latest from origin/main...")
    if run_git_command(["git", "pull", "--rebase", "origin", "main"], "Pull failed (conflict?)") is None:
        print("‚ùó Pull failed. Resolve conflicts manually.")
        if stashed:
            print("üîÅ Attempting to restore stashed changes...")
            result = run_git_command(["git", "stash", "pop"], "Failed to pop stash")
            if result is None:
                print("‚ö†Ô∏è  Stash pop failed. Run 'git stash show' and resolve manually.")
        sys.exit(1)

    if stashed:
        print("üîÅ Restoring stashed changes...")
        result = run_git_command(["git", "stash", "pop"], "Failed to restore stashed changes")
        if result is None:
            print("‚ö†Ô∏è  Stash pop had conflicts. Run 'git stash show' and resolve manually.")

    print("‚úÖ Pull completed successfully!")

if __name__ == "__main__":
    main()


================================================================================
FILE: .pytest_cache/README.md
================================================================================
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


================================================================================
FILE: backend/database.py
================================================================================
import os
import sqlite3
from contextlib import contextmanager
from typing import Dict, Any, List
from datetime import datetime

@contextmanager
def get_db(db_name: str = "data/orders.db"):
    """
    Context manager for database connections.
    Args:
        db_name: Database file path (default: data/orders.db)
    Ensures proper handling of connections and automatic closing.
    """
    conn = sqlite3.connect(db_name)
    conn.row_factory = sqlite3.Row
    try:
        yield conn
    finally:
        conn.close()

def get_setting(key: str, db_name: str = "data/orders.db") -> Any:
    """
    Retrieve a setting value from the settings table.
    Args:
        key: The setting key to retrieve
        db_name: Database file path
    Returns:
        The setting value
    """
    with get_db(db_name) as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT value FROM settings WHERE key = ?", (key,))
        result = cursor.fetchone()
        return result['value'] if result else None

def update_setting(key: str, value: Any, db_name: str = "data/orders.db") -> None:
    """
    Update a setting value in the settings table.
    Args:
        key: The setting key to update
        value: The new value
        db_name: Database file path
    """
    with get_db(db_name) as conn:
        cursor = conn.cursor()
        cursor.execute("UPDATE settings SET value = ? WHERE key = ?", (value, key))
        conn.commit()

def create_order(order_data: Dict[str, Any], items: List[Dict[str, Any]], db_name: str = "data/orders.db") -> Dict[str, Any]:
    """
    Create a new order and its items in the database.
    Args:
        order_data: Dictionary containing order details
        items: List of dictionaries containing order item details
        db_name: Database file path
    Returns:
        Dictionary containing the created order with items
    """
    with get_db(db_name) as conn:
        cursor = conn.cursor()
        try:
            # Insert order
            cursor.execute("""
                INSERT INTO orders (
                    order_number, status, created_date, total,
                    requester
                ) VALUES (?, ?, ?, ?, ?)
            """, (
                order_data["order_number"],
                order_data["status"],
                datetime.now().isoformat(),
                order_data["total"],
                order_data["requester"]
            ))
            
            order_id = cursor.lastrowid

            # Insert order items
            for item in items:
                item_total = item["qty_ordered"] * item["price"]
                cursor.execute("""
                    INSERT INTO order_items (
                        order_id, item_code, item_description,
                        project, qty_ordered, price, total
                    ) VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (
                    order_id,
                    item["item_code"],
                    item["item_description"],
                    item["project"],
                    item["qty_ordered"],
                    item["price"],
                    item_total
                ))

            # Fetch the created order with items
            cursor.execute("""
                SELECT 
                    o.*,
                    json_group_array(
                        json_object(
                            'item_code', i.item_code,
                            'item_description', i.item_description,
                            'project', i.project,
                            'qty_ordered', i.qty_ordered,
                            'price', i.price,
                            'total', i.total
                        )
                    ) as items
                FROM orders o
                LEFT JOIN order_items i ON o.id = i.order_id
                WHERE o.id = ?
                GROUP BY o.id
            """, (order_id,))
            
            conn.commit()
            return dict(cursor.fetchone())

        except sqlite3.Error:
            conn.rollback()
            raise

def init_db(db_name: str = "data/orders.db"):
    # Ensure data directory exists
    os.makedirs("data", exist_ok=True)
    
    # Connect to SQLite database
    conn = sqlite3.connect(db_name)
    cursor = conn.cursor()
    
    # Create orders table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS orders (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            order_number TEXT NOT NULL UNIQUE,
            status TEXT NOT NULL CHECK(status IN ('Pending', 'Awaiting Authorisation', 'Authorised', 'Received', 'Deleted')),
            created_date TEXT NOT NULL,
            received_date TEXT,
            total REAL NOT NULL DEFAULT 0.0,
            order_note TEXT,
            supplier_note TEXT,
            requester TEXT
        )
    """)
    
    # Create order_items table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS order_items (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            order_id INTEGER NOT NULL,
            item_code TEXT,
            item_description TEXT,
            project TEXT,
            qty_ordered INTEGER NOT NULL,
            qty_received INTEGER,
            price REAL,
            total REAL,
            FOREIGN KEY (order_id) REFERENCES orders(id)
        )
    """)
    
    # Create attachments table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS attachments (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            order_id INTEGER NOT NULL,
            filename TEXT NOT NULL,
            file_path TEXT NOT NULL,
            upload_date TEXT NOT NULL,
            FOREIGN KEY (order_id) REFERENCES orders(id)
        )
    """)
    
    # Create users table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT NOT NULL UNIQUE,
            password_hash TEXT NOT NULL,
            rights TEXT NOT NULL CHECK(rights IN ('View', 'Edit'))
        )
    """)
    
    # Create items table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS items (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            item_code TEXT NOT NULL UNIQUE,
            item_description TEXT
        )
    """)
    
    # Create projects table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS projects (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            project_code TEXT NOT NULL UNIQUE
        )
    """)
    
    # Create audit_trail table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS audit_trail (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            order_id INTEGER NOT NULL,
            action TEXT NOT NULL,
            details TEXT,
            action_date TEXT NOT NULL,
            user_id INTEGER,
            FOREIGN KEY (order_id) REFERENCES orders(id),
            FOREIGN KEY (user_id) REFERENCES users(id)
        )
    """)
    
    # Create settings table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS settings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            key TEXT NOT NULL UNIQUE,
            value TEXT NOT NULL
        )
    """)
    
    # Initialize default settings
    cursor.execute("INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)", ("auth_threshold", "10000"))
    cursor.execute("INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)", ("order_number_start", "PO001"))
    
    conn.commit()
    conn.close()

if __name__ == "__main__":
    init_db()


================================================================================
FILE: backend/__init__.py
================================================================================



================================================================================
FILE: backend/main.py
================================================================================
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from backend.endpoints import orders
from backend.database import init_db

# Initialize the database
init_db()

app = FastAPI(
    title="Universal Recycling Purchase Order System",
    description="Purchase Order management system for Universal Recycling"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with specific origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include the orders router
app.include_router(orders.router)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8004)


================================================================================
FILE: scripts/prepare_lookup_tables.py
================================================================================
import sqlite3

conn = sqlite3.connect("data/orders.db")
cursor = conn.cursor()

# Create suppliers table with full structure
cursor.execute("""
CREATE TABLE IF NOT EXISTS suppliers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    account_number TEXT,
    name TEXT,
    tel TEXT,
    vat_number TEXT,
    registration_number TEXT,
    email TEXT,
    contact_name TEXT,
    contact_tel TEXT,
    address_line_1 TEXT,
    address_line_2 TEXT,
    address_line_3 TEXT,
    postal_code TEXT
)
""")

# Create projects table if missing
cursor.execute("CREATE TABLE IF NOT EXISTS projects (id INTEGER PRIMARY KEY AUTOINCREMENT, project_code TEXT NOT NULL UNIQUE)")

# Create items table if missing
cursor.execute("CREATE TABLE IF NOT EXISTS items (id INTEGER PRIMARY KEY AUTOINCREMENT, item_code TEXT NOT NULL UNIQUE, item_description TEXT)")

# Create users table if missing
cursor.execute("""
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    rights TEXT NOT NULL CHECK(rights IN ('View', 'Edit'))
)
""")

# Insert blank placeholder suppliers
for _ in range(3):
    cursor.execute("""
    INSERT INTO suppliers (
        account_number, name, tel, vat_number, registration_number,
        email, contact_name, contact_tel, address_line_1, address_line_2,
        address_line_3, postal_code
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, tuple("" for _ in range(12)))

conn.commit()
conn.close()
print("‚úÖ Lookup tables prepared with full supplier structure.")


================================================================================
FILE: scripts/insert_upload_attachment.py
================================================================================
from pathlib import Path

TARGET = Path("backend/endpoints/orders.py")

upload_route = '''
from fastapi import UploadFile, File, Form
import os

@router.post("/upload_attachment")
async def upload_attachment(order_id: int = Form(...), file: UploadFile = File(...)):
    \"""
    Upload an attachment and link it to an order.
    Saves file to data/uploads and logs entry to DB.
    \"""
    import sqlite3
    from datetime import datetime

    # Create upload folder if it doesn't exist
    upload_dir = "data/uploads"
    os.makedirs(upload_dir, exist_ok=True)

    filename = file.filename
    filepath = os.path.join(upload_dir, filename)

    # Save file to disk
    with open(filepath, "wb") as f:
        f.write(await file.read())

    # Log in DB
    try:
        conn = sqlite3.connect("data/orders.db")
        cursor = conn.cursor()
        cursor.execute(\"\"\"
            INSERT INTO attachments (
                order_id, filename, file_path, upload_date
            ) VALUES (?, ?, ?, ?)
        \"\"\", (order_id, filename, filepath, datetime.now().isoformat()))
        conn.commit()
        conn.close()
        return {"message": "Attachment uploaded", "filename": filename}
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
'''

if __name__ == "__main__":
    text = TARGET.read_text()
    insert_point = text.rfind('@router.get')
    updated = text[:insert_point] + upload_route.strip() + '\n\n' + text[insert_point:]
    TARGET.write_text(updated)
    print("‚úÖ /upload_attachment route injected.")


================================================================================
FILE: scripts/insert_twilio_placeholder.py
================================================================================
from pathlib import Path

orders_path = Path("backend/endpoints/orders.py")
code = orders_path.read_text()

marker = "status = determine_status(total, auth_threshold)"
block = '''status = determine_status(total, auth_threshold)

        if total > auth_threshold:
            # üîî Placeholder: Send Twilio WhatsApp notification to authorisers
            # from ..integrations.whatsapp import notify_authorisers
            # notify_authorisers(order_number=order.order_number, amount=total)
            print(f"[WHATSAPP] Order {order.order_number} exceeds threshold, notify for auth.")'''

if marker in code:
    updated = code.replace(marker, block)
    orders_path.write_text(updated)
    print("‚úÖ Twilio placeholder injected.")
else:
    print("‚ùå Could not find injection marker. No changes made.")


================================================================================
FILE: scripts/insert_get_all_orders.py
================================================================================
from pathlib import Path

TARGET_FILE = Path("backend/endpoints/orders.py")

new_route_code = '''
@router.get("/all")
async def get_all_orders():
    \"\"\"
    Retrieve all orders regardless of status.
    \"\"\"
    try:
        conn = sqlite3.connect("data/orders.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        cursor.execute(\"\"\"
            SELECT id, order_number, status, created_date, total,
                   order_note, supplier_note, requester
            FROM orders
        \"\"\")

        orders = cursor.fetchall()
        conn.close()

        result = []
        for order in orders:
            result.append({
                "id": order["id"],
                "order_number": order["order_number"],
                "status": order["status"],
                "created_date": datetime.fromisoformat(order["created_date"]).strftime("%d/%m/%Y"),
                "total": order["total"],
                "order_note": order["order_note"],
                "supplier_note": order["supplier_note"],
                "requester": order["requester"]
            })

        return {"orders": result}

    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
'''
if __name__ == "__main__":
    content = TARGET_FILE.read_text()
    insert_point = content.rfind('@router.get')
    updated = content[:insert_point] + new_route_code.strip() + '\n\n' + content[insert_point:]
    TARGET_FILE.write_text(updated)
    print("‚úÖ /all orders route injected.")


================================================================================
FILE: scripts/insert_test_order.py
================================================================================
import sqlite3
from datetime import datetime

conn = sqlite3.connect("data/orders.db")
cursor = conn.cursor()

# Create order
cursor.execute("""
    INSERT INTO orders (
        order_number, status, created_date, total,
        order_note, supplier_note, requester
    ) VALUES (?, ?, ?, ?, ?, ?, ?)
""", (
    "PO_TEST_001",
    "Pending",
    datetime.now().isoformat(),
    999.99,
    "This is a test order note",
    "This is a supplier note",
    "Steven"
))
order_id = cursor.lastrowid

# Add line items
items = [
    ("TEST001", "Test Widget A", "Project A", 3, 0, 100.00, 300.00),
    ("TEST002", "Test Widget B", "Project B", 2, 0, 349.99, 699.99)
]

for item in items:
    cursor.execute("""
        INSERT INTO order_items (
            order_id, item_code, item_description, project,
            qty_ordered, qty_received, price, total
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    """, (order_id, *item))

conn.commit()
conn.close()
print("‚úÖ Test order inserted.")


================================================================================
FILE: scripts/insert_next_order_number_route.py
================================================================================
from pathlib import Path

TARGET = Path("backend/endpoints/orders.py")

new_route = """
@router.get("/next_order_number")
async def get_next_order_number():
    from ..database import get_setting
    current = get_setting("order_number_start")
    return {"next_order_number": current}
"""

if __name__ == "__main__":
    content = TARGET.read_text()
    inject_index = content.rfind("@router.get")
    updated = content[:inject_index] + new_route.strip() + "\n\n" + content[inject_index:]
    TARGET.write_text(updated)
    print("‚úÖ /orders/next_order_number route injected.")


================================================================================
FILE: scripts/insert_pending_route.py
================================================================================
from pathlib import Path

# Target: orders endpoint file
TARGET_FILE = Path("backend/endpoints/orders.py")

# Code to inject
pending_route_code = '''
@router.get("/pending")
async def get_pending_orders():
    \"\"\"
    Retrieve all pending orders, each with full item breakdown.
    \"\"\"
    try:
        conn = sqlite3.connect("data/orders.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        cursor.execute(\"\"\"
            SELECT 
                o.id, o.order_number, o.created_date, o.total,
                o.order_note, o.supplier_note, o.requester
            FROM orders o
            WHERE o.status = 'Pending'
        \"\"\")

        orders = cursor.fetchall()
        full_result = []

        for order in orders:
            cursor.execute(\"\"\"
                SELECT 
                    item_code, item_description, project,
                    qty_ordered, qty_received, price, total
                FROM order_items
                WHERE order_id = ?
            \"\"\", (order["id"],))
            items = [dict(row) for row in cursor.fetchall()]
            
            full_result.append({
                "id": order["id"],
                "order_number": order["order_number"],
                "created_date": datetime.fromisoformat(order["created_date"]).strftime("%d/%m/%Y"),
                "total": order["total"],
                "order_note": order["order_note"],
                "supplier_note": order["supplier_note"],
                "requester": order["requester"],
                "items": items
            })

        conn.close()
        return {"pending_orders": full_result}

    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
'''

if __name__ == "__main__":
    content = TARGET_FILE.read_text()
    split_point = content.rfind('@router.get')
    updated = content[:split_point] + pending_route_code.strip()
    TARGET_FILE.write_text(updated)
    print("‚úÖ /pending route injected successfully.")


================================================================================
FILE: scripts/test_create_full_order.py
================================================================================
import requests

order_payload = {
    "requester": "Aaron",
    "supplier_id": 1,
    "order_note": "Urgent delivery required.",
    "supplier_note": "Please ensure all parts are in stock.",
    "items": [
        {
            "item_code": "VALVE001",
            "item_description": "3-inch BSP Ball Valve",
            "project": "Project X",
            "qty_ordered": 2,
            "price": 1200.50
        },
        {
            "item_code": "FLANGE002",
            "item_description": "Steel Flange 4-hole",
            "project": "Project Y",
            "qty_ordered": 5,
            "price": 350.00
        }
    ]
}

response = requests.post("http://localhost:8004/orders", json=order_payload)
print("Status Code:", response.status_code)
print("Response:", response.json())


================================================================================
FILE: scripts/start_server_background.py
================================================================================
import os
import subprocess
from pathlib import Path

project_dir = Path("/Users/stevencohen/Projects/universal_recycling/orders_project")
venv_activate = project_dir / "venv/bin/activate"
log_file = project_dir / "uvicorn.log"

# Build the command to run in the background
command = f"cd {project_dir} && source {venv_activate} && uvicorn backend.main:app --host 0.0.0.0 --port 8004 --reload > {log_file} 2>&1 &"

print("üöÄ Starting Uvicorn server in background...")
subprocess.run(command, shell=True, executable="/bin/bash")
print(f"‚úÖ Server running. Logs ‚Üí {log_file}")


================================================================================
FILE: scripts/insert_audit_tracking_into_receive.py
================================================================================
from pathlib import Path

TARGET_FILE = Path("backend/endpoints/orders.py")

audit_block = """
        # Insert into audit trail
        for item in received_items:
            cursor.execute(\"\"\"
                INSERT INTO audit_trail (
                    order_id, action, details, action_date, user_id
                ) VALUES (?, ?, ?, ?, ?)
            \"\"\", (
                order_id,
                'Received',
                f\"Item {item['item_code']} marked as received (qty: {item['qty_received']})\",
                datetime.now().isoformat(),
                1  # Placeholder user_id = 1 (Steven)
            ))
"""

if __name__ == "__main__":
    text = TARGET_FILE.read_text()

    # Inject after the last cursor.execute in receive route (before checking if fully received)
    insert_point = text.find("        # Check if order is fully received")
    if insert_point == -1:
        print("‚ùå Could not locate insert point. Aborting.")
        exit(1)

    updated = text[:insert_point] + audit_block + "\n" + text[insert_point:]
    TARGET_FILE.write_text(updated)
    print("‚úÖ Audit trail injection complete.")


================================================================================
FILE: scripts/insert_receive_route.py
================================================================================
from pathlib import Path

TARGET_FILE = Path("backend/endpoints/orders.py")

receive_route_code = '''
@router.post("/receive")
async def receive_order(payload: dict):
    \"\"\"
    Mark items in an order as received.
    Updates qty_received, status, and received_date if fully received.
    \"\"\"
    import sqlite3
    from datetime import datetime

    order_id = payload.get("order_id")
    received_items = payload.get("items", [])

    if not order_id or not received_items:
        raise HTTPException(status_code=400, detail="Missing order_id or items.")

    try:
        conn = sqlite3.connect("data/orders.db")
        cursor = conn.cursor()

        # Update each item's qty_received
        for item in received_items:
            cursor.execute(\"\"\"
                UPDATE order_items
                SET qty_received = ?
                WHERE order_id = ? AND item_code = ?
            \"\"\", (
                item["qty_received"],
                order_id,
                item["item_code"]
            ))

        # Check if order is fully received
        cursor.execute(\"\"\"
            SELECT qty_ordered, qty_received
            FROM order_items
            WHERE order_id = ?
        \"\"\", (order_id,))
        all_items = cursor.fetchall()

        fully_received = all(
            qty_received is not None and qty_received >= qty_ordered
            for qty_ordered, qty_received in all_items
        )

        if fully_received:
            cursor.execute(\"\"\"
                UPDATE orders
                SET status = 'Received',
                    received_date = ?
                WHERE id = ?
            \"\"\", (datetime.now().isoformat(), order_id))
        conn.commit()
        conn.close()
        return {\"message\": \"Order updated successfully\", \"fully_received\": fully_received}

    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")
'''
if __name__ == "__main__":
    content = TARGET_FILE.read_text()
    insert_point = content.rfind('@router.get')
    updated = content[:insert_point] + receive_route_code.strip() + '\n\n' + content[insert_point:]
    TARGET_FILE.write_text(updated)
    print("‚úÖ /receive route injected.")


================================================================================
FILE: scripts/insert_extended_order_route.py
================================================================================
from pathlib import Path

TARGET = Path("backend/endpoints/orders.py")

injected_code = '''
@router.post("")
async def create_new_order(order: OrderCreate):
    from ..database import create_order, get_setting, update_setting
    from ..utils.order_utils import generate_order_number, determine_status, validate_order_items
    import sqlite3
    from datetime import datetime

    try:
        validate_order_items(order.items)
        total = order.total

        auth_threshold = float(get_setting("auth_threshold"))
        current_order_number = get_setting("order_number_start")

        if not order.order_number:
            order.order_number = generate_order_number(current_order_number)
            next_order_number = generate_order_number(order.order_number)
            update_setting("order_number_start", next_order_number)

        status = determine_status(total, auth_threshold)

        with sqlite3.connect("data/orders.db") as conn:
            cursor = conn.cursor()
            cursor.execute("INSERT OR IGNORE INTO requesters (name) VALUES (?)", (order.requester,))
            conn.commit()

        order_data = order.model_dump()
        order_data["status"] = status
        order_data["total"] = total

        result = create_order(order_data=order_data, items=[item.model_dump() for item in order.items])
        result["created_date"] = datetime.fromisoformat(result["created_date"]).strftime("%d/%m/%Y")

        return {"message": "Order created successfully", "order": result}
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error: {str(e)}")
'''

if __name__ == "__main__":
    text = TARGET.read_text()
    insert_index = text.rfind("@router.get")
    updated_code = text[:insert_index] + injected_code.strip() + "\n\n" + text[insert_index:]
    TARGET.write_text(updated_code)
    print("‚úÖ Extended /orders route injected.")


================================================================================
FILE: scripts/insert_audit_route.py
================================================================================
from pathlib import Path

TARGET = Path("backend/endpoints/orders.py")

audit_route = '''
@router.get("/audit/{order_id}")
async def get_audit_trail(order_id: int):
    \"\"\"Retrieve audit trail entries for a given order.\"\"\"
    import sqlite3
    try:
        conn = sqlite3.connect("data/orders.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        cursor.execute(\"\"\"
            SELECT action, details, action_date
            FROM audit_trail
            WHERE order_id = ?
            ORDER BY action_date
        \"\"\", (order_id,))
        logs = cursor.fetchall()
        conn.close()
        return {"audit_trail": [dict(row) for row in logs]}
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
'''
if __name__ == "__main__":
    text = TARGET.read_text()
    insert_point = text.rfind('@router.get')
    updated = text[:insert_point] + audit_route.strip() + '\n\n' + text[insert_point:]
    TARGET.write_text(updated)
    print("‚úÖ /audit/{order_id} route injected.")


================================================================================
FILE: scripts/patch_ordercreate_model.py
================================================================================
from pathlib import Path

target = Path("backend/endpoints/orders.py")
code = target.read_text()

patched = []
in_model = False

for line in code.splitlines():
    if line.strip().startswith("class OrderCreate("):
        in_model = True
    if in_model and "items:" in line:
        patched.append("    order_note: Optional[str] = None")
        patched.append("    supplier_note: Optional[str] = None")
        patched.append("    supplier_id: Optional[int] = None")
    patched.append(line)
    if in_model and line.strip().startswith("items:"):
        in_model = False

target.write_text("\n".join(patched))
print("‚úÖ OrderCreate model patched with order_note, supplier_note, and supplier_id")


================================================================================
FILE: scripts/export_all_code.py
================================================================================
from pathlib import Path

# Set the root of the project and output file
project_root = Path(__file__).resolve().parents[1]
output_path = project_root / "full_script_dump.txt"

# Define which file types to include
target_extensions = {".py", ".html", ".js", ".css", ".md"}

# Collect all content
lines = []
for file in project_root.rglob("*"):
    if (
        file.is_file()
        and file.suffix in target_extensions
        and "venv" not in file.parts
        and "__pycache__" not in file.parts
    ):
        try:
            content = file.read_text(encoding="utf-8").strip()
            rel_path = file.relative_to(project_root)
            lines.append(f"{'='*80}\nFILE: {rel_path}\n{'='*80}\n{content}\n")
        except Exception as e:
            lines.append(f"{'='*80}\nFILE: {rel_path}\nERROR READING FILE: {e}\n")

# Write to a single markdown/text file
output_path.write_text("\n\n".join(lines), encoding="utf-8")
print(f"‚úÖ Done. Contents written to: {output_path}")


================================================================================
FILE: scripts/insert_awaiting_auth_order.py
================================================================================
import sqlite3
from datetime import datetime

conn = sqlite3.connect("data/orders.db")
cursor = conn.cursor()

# Create high-value order
cursor.execute("""
    INSERT INTO orders (
        order_number, status, created_date, total,
        order_note, supplier_note, requester
    ) VALUES (?, ?, ?, ?, ?, ?, ?)
""", (
    "PO_TEST_002",
    "Awaiting Authorisation",
    datetime.now().isoformat(),
    15000.00,
    "High value test order",
    "Urgent supplier note",
    "Steven"
))
order_id = cursor.lastrowid

# Add line items
items = [
    ("TEST003", "Expensive Valve", "Project Z", 5, 0, 3000.00, 15000.00)
]

for item in items:
    cursor.execute("""
        INSERT INTO order_items (
            order_id, item_code, item_description, project,
            qty_ordered, qty_received, price, total
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    """, (order_id, *item))

conn.commit()
conn.close()
print("‚úÖ Awaiting Authorisation test order inserted.")


================================================================================
FILE: scripts/test_receive_po_test_001.py
================================================================================
import requests

payload = {
    "order_id": 3,
    "items": [
        { "item_code": "TEST001", "qty_received": 3 },
        { "item_code": "TEST002", "qty_received": 2 }
    ]
}

response = requests.post("http://localhost:8004/orders/receive", json=payload)
print("Status Code:", response.status_code)
print("Response:", response.json())


================================================================================
FILE: frontend/templates/index.html
================================================================================



================================================================================
FILE: frontend/templates/pending.html
================================================================================



================================================================================
FILE: frontend/templates/received.html
================================================================================



================================================================================
FILE: frontend/templates/maintenance.html
================================================================================



================================================================================
FILE: frontend/templates/audit.html
================================================================================



================================================================================
FILE: frontend/templates/new_order.html
================================================================================



================================================================================
FILE: frontend/static/css/styles.css
================================================================================



================================================================================
FILE: frontend/static/js/scripts.js
================================================================================



================================================================================
FILE: backend/endpoints/__init__.py
================================================================================
"""
API endpoints for Universal Recycling Purchase Order System
"""


================================================================================
FILE: backend/endpoints/orders.py
================================================================================
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime
import sqlite3

from ..database import create_order, get_setting, update_setting
from ..utils.order_utils import generate_order_number, determine_status, validate_order_items

router = APIRouter(prefix="/orders", tags=["orders"])

class OrderItem(BaseModel):
    item_code: str = Field(min_length=1)
    item_description: str = Field(min_length=1)
    project: str = Field(min_length=1)
    qty_ordered: float = Field(gt=0)
    price: float = Field(ge=0)

    @property
    def total(self) -> float:
        return self.qty_ordered * self.price

class OrderCreate(BaseModel):
    order_number: Optional[str] = None
    requester: str = Field(min_length=1)
    order_note: Optional[str] = None
    supplier_note: Optional[str] = None
    supplier_id: Optional[int] = None
    items: List[OrderItem] = Field(min_length=1)

    @property
    def total(self) -> float:
        return sum(item.total for item in self.items)

@router.post("")
async def create_new_order(order: OrderCreate):
    """
    Create a new purchase order.
    Args:
        order: OrderCreate model containing order details and items
    Returns:
        Created order with items and status
    Raises:
        HTTPException: For database errors or validation failures
    """
    try:
        # Validate order items
        validate_order_items(order.items)

        # Calculate total
        total = order.total

        # Get settings
        auth_threshold = float(get_setting("auth_threshold"))
        current_order_number = get_setting("order_number_start")

        # Generate order number if not provided
        if not order.order_number:
            order.order_number = generate_order_number(current_order_number)
            # Generate the next order number and update settings
            next_order_number = generate_order_number(order.order_number)
            update_setting("order_number_start", next_order_number)

        # Determine status based on total
        status = determine_status(total, auth_threshold)

        if total > auth_threshold:
            # üîî Placeholder: Send Twilio WhatsApp notification to authorisers
            # from ..integrations.whatsapp import notify_authorisers
            # notify_authorisers(order_number=order.order_number, amount=total)
            print(f"[WHATSAPP] Order {order.order_number} exceeds threshold, notify for auth.")

        # Prepare order data
        order_data = order.model_dump()
        order_data["status"] = status
        order_data["total"] = total

        # Create order and items in database
        result = create_order(
            order_data=order_data,
            items=[item.model_dump() for item in order.items]
        )

        # Format the date in response
        result["created_date"] = datetime.fromisoformat(result["created_date"]).strftime("%d/%m/%Y")

        return {
            "message": "Order created successfully",
            "order": result
        }

    except sqlite3.Error as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )
    except ValueError as e:
        raise HTTPException(
            status_code=400,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"An unexpected error occurred: {str(e)}"
        )

@router.get("/all")
async def get_all_orders():
    """
    Retrieve all orders regardless of status.
    """
    try:
        conn = sqlite3.connect("data/orders.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        cursor.execute("""
            SELECT id, order_number, status, created_date, total,
                   order_note, supplier_note, requester
            FROM orders
        """)

        orders = cursor.fetchall()
        conn.close()

        result = []
        for order in orders:
            result.append({
                "id": order["id"],
                "order_number": order["order_number"],
                "status": order["status"],
                "created_date": datetime.fromisoformat(order["created_date"]).strftime("%d/%m/%Y"),
                "total": order["total"],
                "order_note": order["order_note"],
                "supplier_note": order["supplier_note"],
                "requester": order["requester"]
            })

        return {"orders": result}

    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")

@router.post("/receive")
async def receive_order(payload: dict):
    """
    Mark items in an order as received.
    Updates qty_received, status, and received_date if fully received.
    """
    import sqlite3
    from datetime import datetime

    order_id = payload.get("order_id")
    received_items = payload.get("items", [])

    if not order_id or not received_items:
        raise HTTPException(status_code=400, detail="Missing order_id or items.")

    try:
        conn = sqlite3.connect("data/orders.db")
        cursor = conn.cursor()

        # Update each item's qty_received
        for item in received_items:
            cursor.execute("""
                UPDATE order_items
                SET qty_received = ?
                WHERE order_id = ? AND item_code = ?
            """, (
                item["qty_received"],
                order_id,
                item["item_code"]
            ))


        # Insert into audit trail
        for item in received_items:
            cursor.execute("""
                INSERT INTO audit_trail (
                    order_id, action, details, action_date, user_id
                ) VALUES (?, ?, ?, ?, ?)
            """, (
                order_id,
                'Received',
                f"Item {item['item_code']} marked as received (qty: {item['qty_received']})",
                datetime.now().isoformat(),
                1  # Placeholder user_id = 1 (Steven)
            ))

        # Check if order is fully received
        cursor.execute("""
            SELECT qty_ordered, qty_received
            FROM order_items
            WHERE order_id = ?
        """, (order_id,))
        all_items = cursor.fetchall()

        fully_received = all(
            qty_received is not None and qty_received >= qty_ordered
            for qty_ordered, qty_received in all_items
        )

        if fully_received:
            cursor.execute("""
                UPDATE orders
                SET status = 'Received',
                    received_date = ?
                WHERE id = ?
            """, (datetime.now().isoformat(), order_id))
        conn.commit()
        conn.close()
        return {"message": "Order updated successfully", "fully_received": fully_received}

    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")

@router.get("/audit/{order_id}")
async def get_audit_trail(order_id: int):
    """Retrieve audit trail entries for a given order."""
    import sqlite3
    try:
        conn = sqlite3.connect("data/orders.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        cursor.execute("""
            SELECT action, details, action_date
            FROM audit_trail
            WHERE order_id = ?
            ORDER BY action_date
        """, (order_id,))
        logs = cursor.fetchall()
        conn.close()
        return {"audit_trail": [dict(row) for row in logs]}
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")

from fastapi import UploadFile, File, Form
import os

@router.post("/upload_attachment")
async def upload_attachment(order_id: int = Form(...), file: UploadFile = File(...)):
    """
    Upload an attachment and link it to an order.
    Saves file to data/uploads and logs entry to DB.
    """
    import sqlite3
    from datetime import datetime

    # Create upload folder if it doesn't exist
    upload_dir = "data/uploads"
    os.makedirs(upload_dir, exist_ok=True)

    filename = file.filename
    filepath = os.path.join(upload_dir, filename)

    # Save file to disk
    with open(filepath, "wb") as f:
        f.write(await file.read())

    # Log in DB
    try:
        conn = sqlite3.connect("data/orders.db")
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO attachments (
                order_id, filename, file_path, upload_date
            ) VALUES (?, ?, ?, ?)
        """, (order_id, filename, filepath, datetime.now().isoformat()))
        conn.commit()
        conn.close()
        return {"message": "Attachment uploaded", "filename": filename}
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")

from fastapi import UploadFile, File, Form
import os

@router.post("/upload_attachment")
async def upload_attachment(order_id: int = Form(...), file: UploadFile = File(...)):
    """
    Upload an attachment and link it to an order.
    Saves file to data/uploads and logs entry to DB.
    """
    import sqlite3
    from datetime import datetime

    # Create upload folder if it doesn't exist
    upload_dir = "data/uploads"
    os.makedirs(upload_dir, exist_ok=True)

    filename = file.filename
    filepath = os.path.join(upload_dir, filename)

    # Save file to disk
    with open(filepath, "wb") as f:
        f.write(await file.read())

    # Log in DB
    try:
        conn = sqlite3.connect("data/orders.db")
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO attachments (
                order_id, filename, file_path, upload_date
            ) VALUES (?, ?, ?, ?)
        """, (order_id, filename, filepath, datetime.now().isoformat()))
        conn.commit()
        conn.close()
        return {"message": "Attachment uploaded", "filename": filename}
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")

@router.post("")
async def create_new_order(order: OrderCreate):
    from ..database import create_order, get_setting, update_setting
    from ..utils.order_utils import generate_order_number, determine_status, validate_order_items
    import sqlite3
    from datetime import datetime

    try:
        validate_order_items(order.items)
        total = order.total

        auth_threshold = float(get_setting("auth_threshold"))
        current_order_number = get_setting("order_number_start")

        if not order.order_number:
            order.order_number = generate_order_number(current_order_number)
            next_order_number = generate_order_number(order.order_number)
            update_setting("order_number_start", next_order_number)

        status = determine_status(total, auth_threshold)

        if total > auth_threshold:
            # üîî Placeholder: Send Twilio WhatsApp notification to authorisers
            # from ..integrations.whatsapp import notify_authorisers
            # notify_authorisers(order_number=order.order_number, amount=total)
            print(f"[WHATSAPP] Order {order.order_number} exceeds threshold, notify for auth.")

        with sqlite3.connect("data/orders.db") as conn:
            cursor = conn.cursor()
            cursor.execute("INSERT OR IGNORE INTO requesters (name) VALUES (?)", (order.requester,))
            conn.commit()

        order_data = order.model_dump()
        order_data["status"] = status
        order_data["total"] = total

        result = create_order(order_data=order_data, items=[item.model_dump() for item in order.items])
        result["created_date"] = datetime.fromisoformat(result["created_date"]).strftime("%d/%m/%Y")

        return {"message": "Order created successfully", "order": result}
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error: {str(e)}")

@router.get("/next_order_number")
async def get_next_order_number():
    from ..database import get_setting
    current = get_setting("order_number_start")
    return {"next_order_number": current}

@router.get("/pending")
async def get_pending_orders():
    """
    Retrieve all pending orders, each with full item breakdown.
    """
    try:
        conn = sqlite3.connect("data/orders.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        cursor.execute("""
            SELECT 
                o.id, o.order_number, o.created_date, o.total,
                o.order_note, o.supplier_note, o.requester
            FROM orders o
            WHERE o.status = 'Pending'
        """)

        orders = cursor.fetchall()
        full_result = []

        for order in orders:
            cursor.execute("""
                SELECT 
                    item_code, item_description, project,
                    qty_ordered, qty_received, price, total
                FROM order_items
                WHERE order_id = ?
            """, (order["id"],))
            items = [dict(row) for row in cursor.fetchall()]
            
            full_result.append({
                "id": order["id"],
                "order_number": order["order_number"],
                "created_date": datetime.fromisoformat(order["created_date"]).strftime("%d/%m/%Y"),
                "total": order["total"],
                "order_note": order["order_note"],
                "supplier_note": order["supplier_note"],
                "requester": order["requester"],
                "items": items
            })

        conn.close()
        return {"pending_orders": full_result}

    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


================================================================================
FILE: backend/tests/__init__.py
================================================================================
"""
Test suite for Universal Recycling Purchase Order System
"""


================================================================================
FILE: backend/tests/test_orders.py
================================================================================
import pytest
from fastapi.testclient import TestClient
from ..main import app
from ..utils.order_utils import generate_order_number, determine_status

client = TestClient(app)

def test_generate_order_number():
    assert generate_order_number("PO001") == "PO002"
    assert generate_order_number("PO999") == "PO1000"

def test_determine_status():
    assert determine_status(5000.0, 10000.0) == "Pending"
    assert determine_status(15000.0, 10000.0) == "Awaiting Authorisation"

def test_create_order():
    test_order = {
        "requester": "Test User",
        "total": 5000.0,
        "items": [
            {
                "item_code": "TEST001",
                "item_description": "Test Item",
                "project": "Test Project",
                "qty_ordered": 1,
                "price": 5000.0
            }
        ]
    }
    
    response = client.post("/orders", json=test_order)
    assert response.status_code == 200
    data = response.json()
    assert data["message"] == "Order created successfully"
    assert data["order"]["status"] == "Pending"


================================================================================
FILE: backend/utils/order_utils.py
================================================================================
from typing import Dict, Any, List
from datetime import datetime

def generate_order_number(current_number: str) -> str:
    """
    Generate the next order number based on the current number.
    Args:
        current_number: Current order number from settings (e.g., "PO001")
    Returns:
        Next order number in sequence
    """
    # Extract the numeric part
    num = int(current_number[2:])
    # Generate new number with leading zeros
    return f"PO{str(num + 1).zfill(3)}"

def determine_status(total: float, auth_threshold: float) -> str:
    """
    Determine order status based on total amount and authorization threshold.
    Args:
        total: Order total amount
        auth_threshold: Authorization threshold from settings
    Returns:
        Status string: either "Pending" or "Awaiting Authorisation"
    """
    return "Awaiting Authorisation" if total > auth_threshold else "Pending"

def validate_order_items(items: List[Any]) -> bool:
    """
    Validate order items and their totals.
    Args:
        items: List of OrderItem objects
    Returns:
        True if valid, raises ValueError if invalid
    """
    if not items:
        raise ValueError("Order must contain at least one item")
    
    for item in items:
        if item.qty_ordered <= 0:
            raise ValueError("Quantity ordered must be greater than 0")
        if item.price < 0:
            raise ValueError("Price cannot be negative")
    
    return True


================================================================================
FILE: backend/utils/__init__.py
================================================================================
"""
Utility functions for Universal Recycling Purchase Order System
"""


================================================================================
FILE: backend/tests/integration/__init__.py
================================================================================
"""
Integration tests for Universal Recycling Purchase Order System
"""


================================================================================
FILE: backend/tests/integration/test_order_pipeline.py
================================================================================
import pytest
from fastapi.testclient import TestClient
from ...main import app
from ...database import create_order
import sqlite3
from datetime import datetime

client = TestClient(app)

@pytest.fixture
def test_db():
    """Set up a clean test database."""
    conn = sqlite3.connect("data/test_orders.db")
    cursor = conn.cursor()
    # Create orders table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS orders (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            order_number TEXT NOT NULL UNIQUE,
            status TEXT NOT NULL,
            created_date TEXT NOT NULL,
            total REAL NOT NULL,
            order_note TEXT,
            supplier_note TEXT,
            requester TEXT
        )
    """)
    # Create order_items table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS order_items (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            order_id INTEGER NOT NULL,
            item_code TEXT,
            item_description TEXT,
            project TEXT,
            qty_ordered INTEGER NOT NULL,
            qty_received INTEGER,
            price REAL,
            total REAL,
            FOREIGN KEY (order_id) REFERENCES orders(id)
        )
    """)
    # Create settings table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS settings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            key TEXT NOT NULL UNIQUE,
            value TEXT NOT NULL
        )
    """)
    # Initialize settings
    cursor.execute("INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)", ("auth_threshold", "10000"))
    cursor.execute("INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)", ("order_number_start", "PO001"))
    # Clear orders and order_items tables
    cursor.execute("DELETE FROM orders")
    cursor.execute("DELETE FROM order_items")
    conn.commit()
    yield conn
    conn.close()

def get_order_count(conn):
    """Helper to count orders in database."""
    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*) FROM orders")
    return cursor.fetchone()[0]

def get_order_by_number(conn, order_number):
    """Helper to fetch order by order_number."""
    cursor = conn.cursor()
    cursor.execute("SELECT id, order_number, status, created_date, total, requester FROM orders WHERE order_number = ?", (order_number,))
    return cursor.fetchone()

def get_orders(status=None, db_name="data/test_orders.db"):
    """Helper to simulate GET /orders using test DB."""
    conn = sqlite3.connect(db_name)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    query = "SELECT id, order_number, status, created_date, total, order_note, supplier_note, requester FROM orders"
    params = []
    if status:
        query += " WHERE status = ?"
        params.append(status)
    cursor.execute(query, params)
    orders = cursor.fetchall()
    conn.close()
    result = []
    for order in orders:
        result.append({
            "id": order[0],
            "order_number": order[1],
            "status": order[2],
            "created_date": datetime.fromisoformat(order[3]).strftime("%d/%m/%Y"),
            "total": order[4],
            "order_note": order[5],
            "supplier_note": order[6],
            "requester": order[7]
        })
    return {"orders": result}

def test_order_pipeline(test_db):
    """Test end-to-end order creation and retrieval."""
    print("\n=== Integration Test: Order Pipeline ===")
    
    # Before: Validate empty database
    before_count = get_order_count(test_db)
    print(f"Before: Database has {before_count} orders")
    assert before_count == 0, "Database should be empty before test"

    # Step 1: Create order directly
    order_data = {
        "order_number": "PO999",
        "status": "Awaiting Authorisation",
        "total": 15000.0,
        "requester": "Integration Test",
        "items": [
            {
                "item_code": "INT001",
                "item_description": "Integration Test Item",
                "project": "Test Project",
                "qty_ordered": 1,
                "price": 15000.0
            }
        ]
    }
    print("Step 1: Creating order directly in test database")
    result = create_order(
        order_data=order_data,
        items=order_data["items"],
        db_name="data/test_orders.db"
    )
    
    # Validate created order
    assert result["order_number"] == "PO999", "Invalid order number"
    assert result["status"] == "Awaiting Authorisation", "Status incorrect"
    assert result["total"] == 15000.0, "Total incorrect"
    assert result["requester"] == "Integration Test", "Requester incorrect"
    assert datetime.strptime(result["created_date"], "%Y-%m-%dT%H:%M:%S.%f"), "Invalid date format"
    print("Step 1 After: Order creation validated")

    # Step 2: Check database after creation
    after_post_count = get_order_count(test_db)
    print(f"After creation: Database has {after_post_count} orders")
    assert after_post_count == 1, "Database should have 1 order after creation"
    db_order = get_order_by_number(test_db, "PO999")
    assert db_order, "Order not found in database"
    assert db_order[2] == "Awaiting Authorisation", "Database status incorrect"
    assert float(db_order[4]) == 15000.0, "Database total incorrect"
    print("Step 2 After: Database state validated")

    # Step 3: GET /orders using test DB
    print("Step 3: Retrieving orders with GET /orders")
    response = get_orders()
    orders = response["orders"]
    assert len(orders) >= 1, "GET should return at least 1 order"
    get_order = next((o for o in orders if o["order_number"] == "PO999"), None)
    assert get_order, "Test order not found in GET response"
    assert get_order["status"] == "Awaiting Authorisation", "GET status incorrect"
    assert get_order["total"] == 15000.0, "GET total incorrect"
    print("Step 3 After: GET response validated")

    # Step 4: GET /orders?status=Awaiting Authorisation using test DB
    print("Step 4: Retrieving filtered orders with GET /orders?status=Awaiting Authorisation")
    response = get_orders(status="Awaiting Authorisation")
    orders = response["orders"]
    assert any(o["order_number"] == "PO999" for o in orders), "Test order not found in filtered GET"
    assert all(o["status"] == "Awaiting Authorisation" for o in orders), "Filtered GET status incorrect"
    print("Step 4 After: Filtered GET validated")

    # Summary
    print("\n=== Test Summary ===")
    print(f"Before: {before_count} orders")
    print(f"After creation: {after_post_count} orders, status={db_order[2]}, total={db_order[4]}")
    print(f"GET: {len(orders)} orders retrieved, matched expected")
    print("All validations passed!")
